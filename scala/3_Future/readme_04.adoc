=== for内包表記(for comprehension)
- http://www.scala-lang.org/files/archive/spec/2.11/06-expressions.html#for-comprehensions-and-for-loops[公式ドキュメント, window="_blank"]
は難しく感じるかもしれない。 +
----
Expr1          ::=  `for' (`(' Enumerators `)' | `{' Enumerators `}')
                       {nl} [`yield'] Expr
Enumerators    ::=  Generator {semi Generator}
Generator      ::=  Pattern1 `<-' Expr {[semi] Guard | semi Pattern1 `=' Expr}
Guard          ::=  `if' PostfixExpr
----
こんなような式の定義が書かれている。なので、簡単に日本語で説明したい。

[quote, For Comprehensions and For Loops]
The translation scheme is as follows.

. p < - e

    p <- e.withFilter { case p => true; case _ => false }

. for (p < - e) yield e′

    e.map { case p => e′ }

. for (p < - e) e′

    e.foreach { case p => e′ }

. for (p < - e; p′ < - e′;…) yield e″

    e.flatMap { case p => for (p′ <- e′;…) yield e″ }

. A generator p <- e followed by a guard if g is translated to a single generator p <- e.withFilter((x1,…,xn) => g) where x1,…,xn are the free variables of p. +
A generator p <- e followed by a value definition p′ = e′ is translated to the following generator of pairs of values, where x and x′ are fresh names:

    (p, p′) <- for (x@p <- e) yield { val x′@p′ = e′; (x, x′) }

- どうだろうか。5 については説明しかねるので、原文をそのままのせている。1 ~ 4 については以下でFutureを使ってに詳細を追っていきたい。 +
2 ~ 4 についてはすべての内包表記がなくなるまで、繰り返し適用される。
- まずは公式サイトのExampleを見てみよう。

.Example
[source, scala]
----
for  { i <- 1 until n
       j <- 1 until i
       if isPrime(i+j) (←if guard)
} yield (i, j)
----
The for comprehension is translated to:
[source, scala]
----
(1 until n)
  .flatMap {
     case i => (1 until i)
       .withFilter { j => isPrime(i+j) }
       .map { case j => (i, j) } }
----
[quote, For Comprehensions and For Loops（日本語訳）]
eが変数バインドを制限するboolean式( `if` )が含まれている場合は（バインドを）ガードする。 +
generatorsとguardsはmap、withFilter、flatMap、およびforeachの4つのメソッドの呼び出しに変換することによって定義される。 +

'''

- さて、まずは簡単なものからやってみる。
[square]
* for (p < - e) yield e′

[source, scala, linenums]
----
scala> val e = Future(1100)
e: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@6d4b1c02

scala> val result = for(p <- e) yield e'
<console>:1: error: unclosed character literal
       val result = for(p <- e) yield e'
                                       ^

scala> val result = for(p <- e) yield p
result: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@382db087
----
そのまま貼り付けて実行すると、e'がないといわれてエラーになる。 +
とりあえず、e'をpとすると実行できる。 resultは `Future(1100)` である。+
` e.map { case p => e′ }` へ変換されていることを思い出すと、必ずしもpでなくても良さそうである。

----
scala> val result2 = for(p <- e) yield 1080
result2: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@53bd8fca

scala> Await.result(result2, Duration.Inf)
res5: Int = 1080
----
`Future#map` の定義を思い出すと　`def map[S](f: T => S)(implicit executor: ExecutionContext): Future[S]` のようになっているため、 +
` e.map { case p => e′ }` の e'はこの場合、1080となり result2は `Future(1080)` である。

- 次はこちらをやってみよう。
[square]
* for (p < - e) e′ +

`e.foreach { case p => e′ }` foreachに変換されるため、戻り型は `Unit` である。printlnを使って確認してみる。

----
scala> val e = Seq(1,2,3)
e: Seq[Int] = List(1, 2, 3)

scala> for( p <- e )(println(p))
1
2
3
----
ifのガードを入れてみる。
----
scala> for( p <- e; if e.length == 2)(println(p))
(No Print)
scala>
----
雰囲気はつかめただろうか。副作用と伴うJavaなどの手続き型言語のfor-loopの処理を行う場合に使えそうであるが、 +
Scalaでは使い所があるのだろうか。

- 最後はこちら。もっともよく使われるであろう形。
* for (p < - e; p′ < - e′;…) yield e″ +

2重ループならflatMapとmapに分解できて、理解もしやすいので試してみる。

----
scala> val e1 = Future { 220 }
e1: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@3be4fcc0

scala> val e2 = Future { 260 }
e2: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@2cc04358

scala> for( p1 <- e1; p2 <- e2) yield( p1,p2 )
res8: scala.concurrent.Future[(Int, Int)] = scala.concurrent.impl.Promise$DefaultPromise@2eeb0f9b

// 公式サイトのとおり、変換する。（ひたむきに）
scala> e1.flatMap{ case p1 => for(p2 <- e2) yield( p1,p2 ) }
res9: scala.concurrent.Future[(Int, Int)] = scala.concurrent.impl.Promise$DefaultPromise@2cd4e16a
// （ひたむきに）
scala> e1.flatMap{ case p1 => e2.map( p2 => ( p1, p2 ) ) }
res10: scala.concurrent.Future[(Int, Int)] = scala.concurrent.impl.Promise$DefaultPromise@413d1baf

----
どうも、変換できているようだ。ともに `Future(220,260)` である。 +
これでは簡単すぎるので、もう少し手をいれたい。ifでガードしてみる。

----
scala> for( p1 <- e1; if p1 == 230; p2 <- e2 ) yield(p1, p2)
res11: scala.concurrent.Future[(Int, Int)] = scala.concurrent.impl.Promise$DefaultPromise@79be91eb

scala> val result2 = for( p1 <- e1; if p1 == 230; p2 <- e2 ) yield(p1, p2)
result2: scala.concurrent.Future[(Int, Int)] = scala.concurrent.impl.Promise$DefaultPromise@2ab9e43e

scala> Await.result(result2, Duration.Inf)
java.util.NoSuchElementException: Future.filter predicate is not satisfied
  at scala.concurrent.Future$$anonfun$filter$1.apply(Future.scala:278)
  at scala.util.Success$$anonfun$map$1.apply(Try.scala:236)
  at scala.util.Try$.apply(Try.scala:191)
  at scala.util.Success.map(Try.scala:236)
  at scala.concurrent.Future$$anonfun$map$1.apply(Future.scala:235)
  at scala.concurrent.Future$$anonfun$map$1.apply(Future.scala:235)
  at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:32)
  at scala.concurrent.impl.ExecutionContextImpl$AdaptedForkJoinTask.exec(ExecutionContextImpl.scala:121)
  at scala.concurrent.forkjoin.ForkJoinTask.doExec(ForkJoinTask.java:260)
  at scala.concurrent.forkjoin.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1339)
  at scala.concurrent.forkjoin.ForkJoinPool.runWorker(ForkJoinPool.java:1979)
  at scala.concurrent.forkjoin.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:107)
----
ifでguardして、p2 < - e2が実行されていないのか、Await.resultで結果を取得しようとすると `NoSuchElementException` が発生する。 +

----
scala> val result2 = for( p1 <- e1; if p1 == 220; p2 <- e2 ) yield(p1,p2)
result2: scala.concurrent.Future[(Int, Int)] = scala.concurrent.impl.Promise$DefaultPromise@2d593b56

scala> Await.result(result2, Duration.Inf)
res14: (Int, Int) = (220,260)
----
ifのguardがtrueの場合、例外は発生しない。 +
さきほどのスタックトレースをみると、以下のとおりなので もう一度 `Future` のソースコードに戻る。 +
----
java.util.NoSuchElementException: Future.filter predicate is not satisfied
  at scala.concurrent.Future$$anonfun$filter$1.apply(Future.scala:278)
----

.Future.scala:278
[source, scala]
----
/** Creates a new future by filtering the value of the current future with a predicate.
 *
 *  If the current future contains a value which satisfies the predicate, the new future will also hold that value.
 *  Otherwise, the resulting future will fail with a `NoSuchElementException`.
 *
 *  If the current future fails, then the resulting future also fails.
 *
 *  Example:
 *  {{{
 *  val f = future { 5 }
 *  val g = f filter { _ % 2 == 1 }
 *  val h = f filter { _ % 2 == 0 }
 *  Await.result(g, Duration.Zero) // evaluates to 5
 *  Await.result(h, Duration.Zero) // throw a NoSuchElementException
 *  }}}
 */
def filter(pred: T => Boolean)(implicit executor: ExecutionContext): Future[T] =
  map {
    r => if (pred(r)) r else throw new NoSuchElementException("Future.filter predicate is not satisfied") // 278行目
  }
----
さきほどのif guardではFuture#filterが呼び出されており、`NoSuchElementException` が `throw` されていることがスタックトレースから読み取れる。

- ifのguardがどのメソッドを呼び出すかは、タイプ（型）の実装による。footnote:[公式サイトを参照のこと。]

=== Akka Actor

****
Scalaで非同期処理を行う際にFutureとともに利用されることの多い、Akka Actorライブラリについて以下の観点で簡単にまとめる。 +
1. actorとは何か +
2. Java並行計算ライブラリの問題点 +
3. Akka Actorの構成
4. tellとask +
5. persistence +
6. clustering +
****
詳細については http://akka.io/docs/[Akka Documentation, window="_blank"]を参照してほしい。

. actorとは何か +
actorの語源は並行計算の数学モデルである https://ja.wikipedia.org/wiki/%E3%82%A2%E3%82%AF%E3%82%BF%E3%83%BC%E3%83%A2%E3%83%87%E3%83%AB[アクターモデル, window="_blank"]
の汎用的基本要素の概念であるアクターである。 +
アクターモデルの基本は「全てのものはアクターである」という哲学である。 +
アクターシステムとしてモデル化可能な最も理解しやすい例が電子メールであり、アカウントをアクター、メールアドレスをアクターのアドレスとする。 +
(以上、wikipediaより抜粋) +

. 既存の並行計算ライブラリの問題点と違い +
- 従来のJava言語で考えてみると、スレッドセーフな実装の際に `synchronized` や `volatile` などを使うが、
`synchronized` はオブジェクトをロックするため、排他制御が必要なる。 ロックするスコープについては細心の注意が必要である。
`volatile`　は共有メモリと作業コピーの間で同期処理を行うが、言語仕様レベルのメモリーモデルの正確な理解が必要で、
実装の難易度が非常に高くデバックは困難である。
ただし最近では `ForkJoinPool(1.7)` や `CompletableFuture(1.8)` など非同期処理やサブタスクを扱える機能が提供されている。

- 比較してアクターシステムにおける特徴を以下にまとめる。
** 個々のアクターは独立しており、メモリや状態を共有することがない。 +
** アクターモデルはキューイング機構（一度に一つのメッセージだけを処理する）を採用することにより、ロックを排除している。 +
** メッセージは常に値のコピーであるため、参照渡しによる可変状態の共有を防ぎ、2つのクライアントが同じ変数に同時にアクセスする可能性もなくなる。 +
** アクターベースのシステムではメソッドを外部に公開することが（必要が）ないため、完全にカプセル化されている。 +

. Akka Actorの構成footnote:[http://doc.akka.io/docs/akka/2.4.0/general/addressing.html] +
Akka Actorのソースコードを見ながら、Actorを構成している要素を整理していく。

.akka.actor.Actor.context
[source, scala]
----
/**
 * Stores the context for this actor, including self, and sender.
 * It is implicit to support operations such as `forward`.
 *
 * WARNING: Only valid within the Actor itself, so do not close over it and
 * publish it to other threads!
 *
 * [[akka.actor.ActorContext]] is the Scala API. `getContext` returns a
 * [[akka.actor.UntypedActorContext]], which is the Java API of the actor
 * context.
 */
implicit val context: ActorContext = {
  val contextStack = ActorCell.contextStack.get
  if ((contextStack.isEmpty) || (contextStack.head eq null))
    throw ActorInitializationException(
      s"You cannot create an instance of [${getClass.getName}] explicitly using the constructor (new). " +
        "You have to use one of the 'actorOf' factory methods to create a new actor. See the documentation.")
  val c = contextStack.head
  ActorCell.contextStack.set(null :: contextStack)
  c
}
----
ActorCell.contextStackは 実際は `java.lang.ThreadLocal` であるが、注目したいのは ActorInitializationExceptionが投げられる可能性があるということと、
context（暗黙変数）がActorCellに依存していることである。

.akka.actor.Actor.self
[source, scala]
----
/**
 * The 'self' field holds the ActorRef for this actor.
 * <p/>
 * Can be used to send messages to itself:
 * <pre>
 * self ! message
 * </pre>
 */
implicit final val self = context.self //MUST BE A VAL, TRUST ME
----
selfは自分自身の参照である。とコメントには記述されている。 +
つまり自分自身は `context.self` なのである。

.akka.actor.ActorContext
[source, scala]
----
/**
 * The actor context - the view of the actor cell from the actor.
 * Exposes contextual information for the actor and the current message.
 *
 * There are several possibilities for creating actors (see [[akka.actor.Props]]
 * for details on `props`):
 *
 * {{{
 * // Java or Scala
 * context.actorOf(props, "name")
 * context.actorOf(props)
 *
 * // Scala
 * context.actorOf(Props[MyActor])
 * context.actorOf(Props(classOf[MyActor], arg1, arg2), "name")
 *
 * // Java
 * getContext().actorOf(Props.create(MyActor.class));
 * getContext().actorOf(Props.create(MyActor.class, arg1, arg2), "name");
 * }}}
 *
 * Where no name is given explicitly, one will be automatically generated.
 */
trait ActorContext extends ActorRefFactory {

  def self: ActorRef

  /**
   * Retrieve the Props which were used to create this actor.
   */
  def props: Props

  ...
----
コメントにある actorOfメソッドは `ActorRefFactory` で定義されているActor生成メソッドである。 +
Actorに戻ろう。 +

.akka.actor.Actor#sender()
[source, scala]
----
/**
 * The reference sender Actor of the last received message.
 * Is defined if the message was sent from another Actor,
 * else `deadLetters` in [[akka.actor.ActorSystem]].
 *
 * WARNING: Only valid within the Actor itself, so do not close over it and
 * publish it to other threads!
 */
final def sender(): ActorRef = context.sender()
----
sender()は最後に自身が受け取ったメッセージの送信元のActorの参照を保持している。 +

.akka.actor.Actor#receive
[source, scala]
----
/**
 * This defines the initial actor behavior, it must return a partial function
 * with the actor logic.
 */
//#receive
def receive: Actor.Receive
//#receive
----
Actorの振る舞いを実装する唯一のメソッドで、戻り型が `Actor.Receive` となっている。 +
`Actor.Receive` はコンパニオンブジェクトに以下のように定義されている。

[source, scala]
----
type Receive = PartialFunction[Any, Unit]
----

ここまで見てきてActorが以下のような構成に成っているのがわかった。（ソースコードの全文は読者自身で確かめて欲しい。） +

`Actor` は `ActorCell` から生成される `ActorContext(.context)` を保持しており .contextには自身への参照、送信元の参照、
親子関係（parent, children, system)といった情報が設定されている。また、.contextは `ActorRefFactory` を継承しており
ライフサイクルに関わる `actorOf` や　`stop` メソッドも参照することが可能である。 +
`ActorRefFactory` は　`ActorRefProvider` の参照も保持している。（actorのproviderの種類については別項で説明する。）
ActorのConfigurationについては `akka.actor.ActorSystem.Settings` に書かれているので、詳細を知りたい場合はそちらを確認することになるのだが、
基本的には公式ドキュメントfootnote:[http://doc.akka.io/docs/akka/2.4.0/general/configuration.html]を参照すれば事足りるであろう。

. tellとask +
理論的な話はこのくらいにして、具体的にAkka Actorを使うために知るべきことにフォーカスを当てていきたい。

- tell

- ask

. persistence +

. clustering +

'''
