== Option

****
Scalaの特徴的な型としてOption型を説明する。
Option型を上手に使用するためのコツや、代表的な使用例を説明する。
最後にOption型による例外処理を取り上げる。
****

いきなりだがソースコードを見ていく。

.scala.Option#apply

[source, java]
----
object Option {

  import scala.language.implicitConversions

  /** An implicit conversion that converts an option to an iterable value
   */
  implicit def option2Iterable[A](xo: Option[A]): Iterable[A] = xo.toList

  /** An Option factory which creates Some(x) if the argument is not null,
   *  and None if it is null.
   *
   *  @param  x the value
   *  @return   Some(value) if value != null, None if value == null
   */
  def apply[A](x: A): Option[A] = if (x == null) None else Some(x)

  /** An Option factory which returns `None` in a manner consistent with
   *  the collections hierarchy.
   */
  def empty[A] : Option[A] = None
}
----

- applyメソッドはScalaでは特別なメソッドとして解釈される。つまりOptionは以下のように生成できることになる。

[source, java]
----
val opt = Option("this is option type.")
----

- applyメソッドによりこれは `Some("this is option type.")` となる。

- またapplyメソッドはOptionコンパニオンオブジェクトに定義されている。

NOTE: コンパニオンオブジェクトやapplyメソッドや抽出子(unapply)については別項で説明するものとする。

さらにソースコードを見ていく。

.scala.Option#get
[source, java]
----
/** Returns the option's value.
 *  @note The option must be nonEmpty.
 *  @throws Predef.NoSuchElementException if the option is empty.
 */
def get: A

/** Returns the option's value if the option is nonempty, otherwise
 * return the result of evaluating `default`.
 *
 *  @param default  the default expression.
 */
@inline final def getOrElse[B >: A](default: => B): B =
  if (isEmpty) default else this.get
----
- getメソッドの戻り値がA型となっており、Option[String]型であればString型が取得できることがわかる。
- getOtElseメソッドはisEmptyの実装（後述）によりデフォルト値を返却する場合とgetを呼び出す分岐がある。
- これらのメソッドはabstract class で定義されており、Optionの具象クラスはcase class として *Some* と *None* が定義されている。さらにこれらクラスにisEmptyの実装がある。

'''
[square]
* さて、ここまででもOptionを生成して値を取り出すことがなんとなくできるようになった。ここからはさらに便利な定義済メソッドを見ていく。

.scala.Option#map
[source, java]
----
/** Returns a $some containing the result of applying $f to this $option's
 * value if this $option is nonempty.
 * Otherwise return $none.
 *
 *  @note This is similar to `flatMap` except here,
 *  $f does not need to wrap its result in an $option.
 *
 *  @param  f   the function to apply
 *  @see flatMap
 *  @see foreach
 */
@inline final def map[B](f: A => B): Option[B] =
  if (isEmpty) None else Some(f(this.get))

/** Returns the result of applying $f to this $option's
 *  value if the $option is nonempty.  Otherwise, evaluates
 *  expression `ifEmpty`.
 *
 *  @note This is equivalent to `$option map f getOrElse ifEmpty`.
 *
 *  @param  ifEmpty the expression to evaluate if empty.
 *  @param  f       the function to apply if nonempty.
 */
@inline final def fold[B](ifEmpty: => B)(f: A => B): B =
  if (isEmpty) ifEmpty else f(this.get)

/** Returns the result of applying $f to this $option's value if
 * this $option is nonempty.
 * Returns $none if this $option is empty.
 * Slightly different from `map` in that $f is expected to
 * return an $option (which could be $none).
 *
 *  @param  f   the function to apply
 *  @see map
 *  @see foreach
 */
@inline final def flatMap[B](f: A => Option[B]): Option[B] =
  if (isEmpty) None else f(this.get)
----
* mapメソッドを実際に使ってみよう。

[source, java]
----
val opt = Option("helo")
val b = opt.map(a => Seq(a))
----
bは実際にSome(List(helo))のようなオブジェクトになる。

* flatMapはどうか？

[source, java]
----
val opt = Option("helo")
val b = opt.flatMap(a => Seq(a))
----
[%hardbreaks]
これは [red]_error: type mismatch;_となりコンパイルできない。なぜか。
flatMapの引数は `(f: A => Option[B])` になっており、マッピング先の型はOption型でなければならない。
以下のような形であればコンパイルできる。

[source, java]
----
val opt = Option("helo")
val b = opt.flatMap(a => Some(Seq(a)))
----
bは実際にSome(List(helo))のようなオブジェクトになる。

* mapとflatMapの違い
** `f(this.get)` を呼び出すことは変わりはないが、mapの場合は自身の関数の中でSomeでラップしており、flatMapは引数の関数の戻り値にOption型を要求することで自身の戻り値をOption型としている。

* foldの使用例

[source, java]
----
val opt = Option("helo")
val b = opt.fold(Some(Seq("none")))(a => Some(Seq(a)))
----
isEmptyがtrue(Noneの場合)は第一引数の関数（左側の関数）が実行され、そうでない場合は第二引数の関数（右側の関数）が実行される。

'''
上記のメソッド以外にも便利なメソッドがOptionクラスには定義されているが、最後にcollectメソッドをみてみよう。

.scala.Option#collect
[source, java]
----
/** Returns a $some containing the result of
 * applying `pf` to this $option's contained
 * value, '''if''' this option is
 * nonempty '''and''' `pf` is defined for that value.
 * Returns $none otherwise.
 *
 *  @param  pf   the partial function.
 *  @return the result of applying `pf` to this $option's
 *  value (if possible), or $none.
 */
@inline final def collect[B](pf: PartialFunction[A, B]): Option[B] =
  if (!isEmpty && pf.isDefinedAt(this.get)) Some(pf(this.get)) else None
----
CAUTION: このメソッドは一体何をしてくれるのだろう。
やはりthis.getは呼び出している。またSomeでラップもしている。
戻り値はOption型であるが、PartialFunctionとは？

* 使用例を見てみる。

[source, java]
----
val opt = Option("partial")
val pf: PartialFunction[String,String] = {case "partial" => "bingo!"}
val b = opt.collect(pf)
----
bはSome(bingo!)になっている。

// TODO:PartialFunctionの簡単な説明

=== nullの扱い
. None
. Nothing
. Nil
. null

=== Either
