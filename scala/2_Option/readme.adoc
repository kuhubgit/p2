== Option

****
Scalaの特徴的な型としてOption型を説明する。
Option型を上手に使用するためのコツや、代表的な使用例を説明する。
最後にOption型による例外処理を取り上げる。
****

いきなりだがソースコードを見ていく。

TIP: 以降の章をスムーズに読み進めるために、ソースコードを確認できる環境を整えておくとよい。
IntellijIDEAで適当なScalaプロジェクトを開いて、kbd:[Ctrl+N] (OSXの場合はkbd:[Command+B])で直接エディターで開いてみるのがよいだろう。

=== apply

- applyメソッドはOptionコンパニオンオブジェクトに定義されている。

.scala.Option#apply
[source, scala, linenums]
----
object Option {

  import scala.language.implicitConversions

  /** An implicit conversion that converts an option to an iterable value
   */
  implicit def option2Iterable[A](xo: Option[A]): Iterable[A] = xo.toList

  /** An Option factory which creates Some(x) if the argument is not null,
   *  and None if it is null.
   *
   *  @param  x the value
   *  @return   Some(value) if value != null, None if value == null
   */
  def apply[A](x: A): Option[A] = if (x == null) None else Some(x)

  /** An Option factory which returns `None` in a manner consistent with
   *  the collections hierarchy.
   */
  def empty[A] : Option[A] = None
}
----

- applyメソッドはScalaでは特別なメソッドとして解釈される。つまりOptionは以下のように生成できることになる。

[square]
- Optionの生成

[source, scala]
----
val opt = Option("this is option type.")
opt: Option[String] = Some(this is option type.)
----

NOTE: コンパニオンオブジェクトやapplyメソッドや抽出子(unapply)については別項で説明するものとする。

さらにソースコードを見ていく。

=== get

- getメソッドはOptionから値を取得する一番簡単なメソッドである。しかし `NoSuchElementException` をthrowするため、安易な使用は推奨されない。footnote:[メソッドの特性を理解した上で適宜使い分けたい。getの使用が適当な箇所もあるはずである。]
- ただし、Optionの他メソッド内では値を取得するために使用されているメソッドである。

.scala.Option#get
[source, scala, linenums]
----
/** Returns the option's value.
 *  @note The option must be nonEmpty.
 *  @throws Predef.NoSuchElementException if the option is empty.
 */
def get: A

/** Returns the option's value if the option is nonempty, otherwise
 * return the result of evaluating `default`.
 *
 *  @param default  the default expression.
 */
@inline final def getOrElse[B >: A](default: => B): B =
  if (isEmpty) default else this.get
----
- getメソッドの戻り値がA型となっており、Option[String]型であればString型が取得できることがわかる。
- getOtElseメソッドはisEmptyの実装（後述）によりデフォルト値を返却する場合とgetを呼び出す分岐がある。
- これらのメソッドはabstract class で定義されており、Some(final case class)とNone(case object)にisEmptyの実装がある。
- 実際の場面ではgetやgetOrElseを直接使うよりもmapやflatMapメソッドを経由して値を取り出すことが多いかもしれない。

'''

=== map,flatMap,fold

- 関数型言語で頻出のこれらのメソッドを簡単に押さえておきたい。これらのメソッドシグネチャを理解し、関数的な思考センスを磨きたいところである。

.scala.Option#map
[source, scala, linenums]
----
/** Returns a $some containing the result of applying $f to this $option's
 * value if this $option is nonempty.
 * Otherwise return $none.
 *
 *  @note This is similar to `flatMap` except here,
 *  $f does not need to wrap its result in an $option.
 *
 *  @param  f   the function to apply
 *  @see flatMap
 *  @see foreach
 */
@inline final def map[B](f: A => B): Option[B] =
  if (isEmpty) None else Some(f(this.get))

/** Returns the result of applying $f to this $option's
 *  value if the $option is nonempty.  Otherwise, evaluates
 *  expression `ifEmpty`.
 *
 *  @note This is equivalent to `$option map f getOrElse ifEmpty`.
 *
 *  @param  ifEmpty the expression to evaluate if empty.
 *  @param  f       the function to apply if nonempty.
 */
@inline final def fold[B](ifEmpty: => B)(f: A => B): B =
  if (isEmpty) ifEmpty else f(this.get)

/** Returns the result of applying $f to this $option's value if
 * this $option is nonempty.
 * Returns $none if this $option is empty.
 * Slightly different from `map` in that $f is expected to
 * return an $option (which could be $none).
 *
 *  @param  f   the function to apply
 *  @see map
 *  @see foreach
 */
@inline final def flatMap[B](f: A => Option[B]): Option[B] =
  if (isEmpty) None else f(this.get)
----
* map

[source, scala]
----
val opt = Option("helo")
val b = opt.map(a => Seq(a))
----
bは実際にSome(List(helo))のようなオブジェクトになる。

* flatMap

[source, scala]
----
val opt = Option("helo")
val b = opt.flatMap(a => Seq(a))
----
[%hardbreaks]
これは [red]_error: type mismatch;_ となりコンパイルできない。なぜか。
flatMapの引数は `(f: A => Option[B])` になっており、マッピング先の型はOption型でなければならない。
以下のような形であればコンパイルできる。

[source, scala]
----
val opt = Option("helo")
val b = opt.flatMap(a => Some(Seq(a)))
----
bは実際にSome(List(helo))のようなオブジェクトになる。

* mapとflatMapの違い
** `f(this.get)` を呼び出すことは変わりはないが、mapの場合は自身の関数の中でSomeでラップしており、flatMapは引数の関数の戻り値にOption型を要求することで自身の戻り値をOption型としている。

* fold

[source, scala]
----
val opt = Option("helo")
val b = opt.fold(Some(Seq("none")))(a => Some(Seq(a)))
----
isEmptyがtrue(Noneの場合)は第一引数の関数（左側の関数）が実行され、そうでない場合は第二引数の関数（右側の関数）が実行される。

=== collect

- collectという名称から何かしらの条件にマッチしたものだけを取得できそうなメソッドのような感じを受ける。
- では実際にソースをみていく。

.scala.Option#collect
[source, scala, linenums]
----
/** Returns a $some containing the result of
 * applying `pf` to this $option's contained
 * value, '''if''' this option is
 * nonempty '''and''' `pf` is defined for that value.
 * Returns $none otherwise.
 *
 *  @param  pf   the partial function.
 *  @return the result of applying `pf` to this $option's
 *  value (if possible), or $none.
 */
@inline final def collect[B](pf: PartialFunction[A, B]): Option[B] =
  if (!isEmpty && pf.isDefinedAt(this.get)) Some(pf(this.get)) else None
----
CAUTION: このメソッドは一体何をしてくれるのだろう。
やはりthis.getは呼び出している。またSomeでラップもしている。
戻り値はOption型であるが、PartialFunctionとは？

* 使用例を見てみる。

[source, scala]
----
val opt = Option("partial")
val pf: PartialFunction[String,String] = {case "partial" => "bingo!"}
val b = opt.collect(pf)
----
bはSome(bingo!)になっている。

TODO: PartialFunctionの簡単な説明

=== nullの扱い

* None
- NoneはOption[Nothing]を継承した `case object` である。

.Option.scala
[source, scala, linenums]
----
case object None extends Option[Nothing] {
  def isEmpty = true
  def get = throw new NoSuchElementException("None.get")
}
----

* Nothing
- 通常のコーディングで使うことはまずないと思われる。型である。ただしライブラリの設計を行う場合は概念を理解する必要はありそうだ。
- ここでは深く取り上げないことにする。

* Nil
- 空のListである。List[Nothing]を継承した `case object` である。

.List.scala
[source, scala, linenums]
----
case object Nil extends List[Nothing] {
  override def isEmpty = true
  override def head: Nothing =
    throw new NoSuchElementException("head of empty list")
  override def tail: List[Nothing] =
    throw new UnsupportedOperationException("tail of empty list")
  // Removal of equals method here might lead to an infinite recursion similar to IntMap.equals.
  override def equals(that: Any) = that match {
    case that1: scala.collection.GenSeq[_] => that1.isEmpty
    case _ => false
  }
}
----

* null
- nullはといえば、Scalaにも存在する。ただし使いどころは限定されるようだ。値がないことを表現するにはNoneを使おう。
- ただし、scalaのライブラリを使用している場合は普通にScalaでも `NullPointerException` は発生する。
- 基本的にnullが現れないようなコーディングを心がけたい。

=== Either

=== Try
